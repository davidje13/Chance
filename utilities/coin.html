<html lang="en">
<head>
<meta charset="utf-8">

<title>Coin Profile Generator</title>

<script>window.addEventListener('load', () => {

const texW = 512;
const texH = 512;

const face1 = {x: 0, y: 0, w: 256, h: 256};
const face2 = {x: 256, y: 0, w: 256, h: 256};
const edge = {x: 0, y: 264, w: 512, h: 48}; // active area is y: 272, h: 32

const SQRT3_2 = Math.sqrt(3) / 2;

const fmSides = document.getElementById('sides');
const fmRoundRad = document.getElementById('roundRad');
const fmInset = document.getElementById('inset');
const fmDepth = document.getElementById('depth');
const fmSuggestedDepth = document.getElementById('suggestedDepth');

fmSides.addEventListener('input', renderFromInputs);
fmRoundRad.addEventListener('input', renderFromInputs);
fmInset.addEventListener('input', renderFromInputs);
fmDepth.addEventListener('input', renderFromInputs);

window.devicePixelRatio = 1;
const canvas = document.createElement('canvas');
canvas.width = texW;
canvas.height = texH;
canvas.style.imageRendering = 'pixelated';
canvas.style.border = '1px solid #CCCCCC';
document.body.appendChild(canvas);
const ctx = canvas.getContext('2d');
const dat = ctx.createImageData(texW, texH);

function renderFromInputs() {
	const sides = Math.max(Math.round(fmSides.value), 3);
	const roundingRad = Math.max(0, Math.min(1, fmRoundRad.value));

	render(ctx, {
		sides,
		roundingRad,
		inset: fmInset.value,
		depth: fmDepth.value,
	});
}

function add(a, b) {
	return {x: a.x + b.x, y: a.y + b.y};
}

function sub(a, b) {
	return {x: a.x - b.x, y: a.y - b.y};
}

function normalise(v) {
	const m = 1 / Math.sqrt(dot(v, v));
	return {x: v.x * m, y: v.y * m};
}

function dot(a, b) {
	return a.x * b.x + a.y * b.y;
}

function cross(a, b) {
	return a.x * b.y - a.y * b.x;
}

function dist(a, b) {
	return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

function lineOffset(p, a, b) {
	const dir = normalise(sub(b, a));
	return dot(sub(p, a), {x: dir.y, y: -dir.x});
}

function withinLineBounds(p, a, b) {
	const dir = normalise(sub(b, a));
	const pos = dot(sub(p, a), dir);
	return (pos >= 0 && pos <= dist(a, b));
}

function lineDist(p, a, b) {
	return Math.abs(lineOffset(p, a, b));
}

function lineCircIntersectionDist(ray, centre, rad, back = false) {
	const ee = dot(centre, centre);
	const er = -dot(centre, ray);
	const root = er * er - ee + rad * rad;
	if (root < 0) {
		return Number.POSITIVE_INFINITY;
	}
	return Math.sqrt(root) * (back ? 1 : -1) - er;
}

function step(v, low, high) {
	if (high === low) {
		return v > low ? 1 : 0;
	}
	return Math.max(0, Math.min(1, (v - low) / (high - low)));
}

function quantise(v) {
	return Math.max(0, Math.min(255, Math.floor(v * 256)));
}

function fill(dat, {x, y, w, h}, fn) {
	const pix = 1 / w;
	for (let Y = 0; Y < h; ++ Y) {
		for (let X = 0; X < w; ++ X) {
			const p = {x: (X + 0.5) / w, y: (Y + 0.5) / h};
			const v = quantise(fn(p, pix));
			const dp = ((y + Y) * dat.width + x + X) * 4;
			dat.data[dp  ] = v;
			dat.data[dp+1] = v;
			dat.data[dp+2] = v;
			dat.data[dp+3] = 255;
		}
	}
}

function render(ctx, {sides, roundingRad, inset, depth}) {
	const distC = 1 - roundingRad;
	const rad = roundingRad - inset;
	const centres = [];

	const sideTheta = Math.PI * 2 / sides;

	for (let i = 0; i < sides; ++ i) {
		const theta = i * sideTheta;
		centres.push({x: Math.sin(theta) * distC, y: -Math.cos(theta) * distC});
	}

	function faceLumAt(p, pixel) {
		p.x = p.x * 2 - 1;
		p.y = p.y * 2 - 1;
		let v = rad + pixel + 1;
		let maxO = Number.NEGATIVE_INFINITY;
		for (let i = 0; i < sides; ++ i) {
			const c1 = centres[i];
			const c2 = centres[(i + 1) % sides];
			const o = lineOffset(p, c1, c2);
			const r = dist(p, c1);
			maxO = Math.max(maxO, o);
			v = Math.min(v, r);
			if (withinLineBounds(p, c1, c2)) {
				v = Math.min(v, Math.abs(o));
			}
		}
		if (maxO < 0) {
			v = maxO;
		}
		return step(v, rad - pixel, rad + pixel);
	}

	const outerTheta = Math.PI - sideTheta;
	const lineDelta = {x: rad * Math.cos(outerTheta * 0.5), y: -rad * Math.sin(outerTheta * 0.5)};
	const lineP1 = add(centres[0], lineDelta);
	const lineP2 = add(centres[1], lineDelta);
	const edgeCrossAngle = Math.atan(-lineP1.x / lineP1.y);
	const lineD = sub(lineP2, lineP1);

	let lowest = 1;

	function edgeLumAt(p) {
		let theta = p.x;
		while (theta > 1 / sides) {
			theta -= 1 / sides;
		}
		if (theta > 0.5 / sides) {
			theta = 1 / sides - theta;
		}
		theta = theta * Math.PI * 2;
		const ray = {x: Math.sin(theta), y: -Math.cos(theta)};
		let dist;
		if (theta > edgeCrossAngle) {
			dist = cross(lineP1, lineD) / cross(ray, lineD);
		} else {
			dist = lineCircIntersectionDist(ray, centres[0], rad, true);
		}
		lowest = Math.min(lowest, dist);
		return 1 - (1 - dist) / depth;
	}

	function edgeFaceLumAt(p, pixel) {
		const c = {x: p.x * 2 - 1, y: p.y * 2 - 1};
		const theta = Math.atan2(c.x, c.y);
		const x = theta * 0.5 / Math.PI + 0.5;
		const len = Math.sqrt(dot(c, c));
		const d = 1 - (1 - quantise(edgeLumAt({x, y: 0.5})) / 255) * depth;
		return step(len, d - pixel, d + pixel);
	}

	fill(dat, face1, faceLumAt);
	fill(dat, edge, edgeLumAt);
	fill(dat, face2, edgeFaceLumAt);

	ctx.putImageData(dat, 0, 0);

	fmSuggestedDepth.innerText = (1 - lowest).toFixed(3);
}

renderFromInputs();

});</script>
</head>
<body>
<h1>Coin Profile Generator</h1>
<h2>Rounded Regular Polygon</h2>
<p><label>Sides: <input id="sides" type="number" step="1" min="3" value="3" /></label></p>
<p><label>Rounding radius: <input id="roundRad" type="number" step="any" min="0" max="1" value="0.3587" /></label></p>
<p><label>Inset: <input id="inset" type="number" step="any" min="0" max="1" value="0.0" /></label></p>
<p><label>Edge Max Depth: <input id="depth" type="number" step="any" min="0" max="1" value="0.5" /></label> (suggested: <span id="suggestedDepth">?</span>)</p>
</body>
</html>
